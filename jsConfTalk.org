* Mihi / Greeting
  - Thank you to the conference organizers and other speakers
     
  - Especially those tackling topics, either technically or emotionally and those that address the wider definition of what our community means, sad I can't see them all. This is my first ever talk so thank-you for having me. I think the js community is wide and varied all levels and kinds of experience are important

  - I'm Brooke Mitchell. 

  - I've a developer who has been using JavaScript in earnest for maybe three years. 

   - These are my experiences using lenses and transducers to simplify data manipulation in a redux app I built. 

* Intro - Me and Redux / Clearing up nomenclature

 - My last year I have been pretty heavily focused on react and redux. Don't worry this isn't a talk about react. This talk is a little about my experiences using redux. Really this talk is really about how to deal with pojos (plain old JavaScript objects) (A.K.A dictionaries, hash-maps) something we all use. 

 -  From my experience dictionary manipulation can seems to be one of the less glamorous corners of functional programming; which is actually handy because it skips a lot of prior knowledge expected and you should be able to use any of these techniques in your day-to-day programming. One thing you will notice when using redux, the architecture tends to channel you towards functional approaches, I think is largely due to the inspiration takes from the ELM architecture.

 - Btw when I talk about objects/dictionaries/hash-maps in this talk, I mean pojos. eg {}. No fancy prototypal inheritance here. So since this talk is about my experiences using objects, this talk is about how we use objects, through keys. What are keys? Keys are probably one of the few things in the computing world that I like the name of. They are the items that you provide to a hash function that unlock associated values.  So and when we talk about keys, there is something slightly magical and metaphorical about them. For that reason we should also consider them at a higher conceptual level and consult the master of keys, the one and only, DJ Khaled. [fn:4]
    
 - For those unfamiliar with the work of DJ Khaled, you could briefly describe him as a music mogul and internet celebrity. Perhaps his most impressive skill is to act like a human hash function, and I mean that in a positive way. He can make a meaningful connection between any two people. Say you need Jay-Z and Snoop Dogg to catch a plane to your studio talk to DJ Khaled. So while Khaled is an important music producer, snapchat celebrity, motivational speaker but most importantly for this talk, he is someone who also has a philosophy about keys. (play Khaled keys clip). Khaled describes his steps to success as 'keys' that open access to other keys, so perhaps in another life he dealt with deeply nested JSON responses, lame joke I'm sorry. 
      
* Explaining how to build a redux app
*** Crash course in Redux
 - Anyway back to the app I was building. Sadly it was built for a closed source environment. But here is a smaller toy example that also shows some of the problems that as redux apps get larger. 

...Show app.

Before I show some of the refactorings I think are useful for dealing with objects, I'll try and offer as quick an overview of redux as possible. Hopefully my overview shows you that redux is very similar to mapping and reducing in vanilla js.

- So just to briefly describe what a redux app flow is like from 10,000 feet: 
  You have a store object that holds state.
1. You call store.dispatch(action) -> 
2. The Redux store calls any reducer functions (called 'reducers') that will make changes to state. ->
3. The Redux store replaces the old state tree with a new state tree.
   ...
4. You can subscribe to store updates to apply them to your view. 
   
That's pretty much it, talk over.

- So when building a redux app, apart from the boilerplate, you are essentially doing only two things, writing reducers to hanlde updates and mapping that state to your view. Thats it, reducing and mapping an object.

*** Reducer

Coincidentally a 'reducer' in redux is effectively a 'reduce' for state, I like to think of it like so...

#+BEGIN_SRC js 
const initialState = {loading: true, filter: all}

['ACTION 1', 'STOP_LOADING', 'ACTION 3']
  .reduce((state, action) => {
    if (action.type === 'STOP_LOADING') {
      return Object.assign({}, state, {loading: false})
    }
    else return state
    }
  },  initialState)
#+END_SRC

In reality that list of actions is provided by redux's dispatch function and unfolds over time, more like an observer, but I think its a good way to conceptualize it.

Take special note of the line that looks like this:
#+BEGIN_SRC js 
return Object.assign({}, oldObject, newObject)
#+END_SRC

- Major key alert: don't mutate your state in a reducer. It's an effort that will be ignored anyway in the diff comparison. [fn:3]  What is mutation? Here are some links properly discussing mutation on my slides which you can grab on github. [[https:github.com/brookemitchell][github link]]. Anyway the opposite of mutability is immutability, what is immutability, basically it means keys and values of an object are unchangeable. In practice that means we need to return a fresh new copy of the object every time. [fn:2] ]

*** Mapper
     
Here is a redux mapping of state to a html output, this is pretty low-level and in reality react users tend to use higher-order-components like react-redux connect [[http:github.com/react-redux/react-redux][connect link]], but just to show you that you could happily use redux store in any scenario.

This is a state mapper in hyperscript, a handy way to generate dom nodes directly.
#+BEGIN_SRC js 
import h from 'hyperscript'

const widgetsList = widgets => h('div', h('ul', widgets.map(w => h('li', w))))
store.subscribe(() => {
  const currentState = store.getState()
  const divWithState = widgetsList(currentState.widgets)
})
#+END_SRC

I think writing functions instead of jsx looks pretty nice. JSX is cool too though.

State mappers are pretty much exactly the same for all libraries, I think of them like a .map where you plucks the desired items for an object. 

This is a state mapper using nanocomponent. An very cool new component createion library that runs on any framework and performs well (using the same optimizations as react fiber). It should be compatable with all the frameworks and x-to-js compilers (even elm) and frees us from writing the same components like inifite list a zillion times.

#+BEGIN_SRC js 
const component = require('nanocomponent')
const html = require('bel')

const mapStateToProps = state => ({widgets: state.widgets})
const props = mapStateToProps(store.getState())

var WidgetList = component({
  render: function (props) {
    return html`
      <ul>${props.widgets.map(e => html`<li>${e}</li>`)}</ul>
    `
  }
})
#+END_SRC

Anyway dispatch, reduce, map. That is my summary of redux, so enough of that.

* Real world
- Hopefully you can now see that setting state is the same as applying a reducing function, and getting state is similar to a mapping over state and plucking entries you care about out.

**** Refactoring mapStateToProps

#+BEGIN_SRC js 
function setText (state, action) {...}

export default function works(state = initialState, action) {
  switch (action.type) {
    case WORKS_FETCH_FAILED: {
      return {
        ...state,
        appState: "error",
        error: action.message
      };
    }
    case SET_TEXT: {
    setText(state, action)
    }
    default:
      return state;
  }
}
#+END_SRC

- And here is a troubled mapper. In my toy example as is often the case things weren't looking real world enough, so I decided to add the classic real world case of users provided by a router. Again you dont need to read this, just get a bad feeling.

#+BEGIN_SRC js 
const mapStateToProps = (state, props) => {
  const user = state.users[props.routeParams.uid]
  const userDetails = state.usersDetails[user.uid]
  return {
    userDetails,
    noUser: typeof user === 'undefined',
    name: noUser ? '' : user.info.name,
    lastupdatedUser: user ? user.lastUpdated : 0,
    isFetching: user.isFetching || usersDetails.isFetching,
    error: users.error || usersDucks.error,
    works: state.works.works,
    sending: state.works.sending,
    works: state.works.error,
    editing: R.propOr([], 0)(R.toPairs(state.works.editing))
  };
};
#+END_SRC
- For a quick glance this looks like way too much business logic to have in a view. Also all this nested parameter access is sure to cause runtime errors if a property isn't available at a certain point in time.


Testing takes care a lot of this, but I knew these needed a refactor.

 - Here is the real reducer for the roadworks editing app, this is the function for setting the new shape of the state called every time an 'action' is dispatched. 

#+BEGIN_SRC js 
export default function works(state = initialState, action) {
  switch (action.type) {
    case WORKS_FETCH_FAILED: {
      return {
        ...state,
        appState: "error",
        error: action.message
      };
    }
    case SET_TEXT: {
      const oldItem = state.works[action.changedEntry.id];
      const newItem = action.changedEntry[action.changedEntry.id];

      const mergedEntry = {
        works: {
          ...state.works,
          [action.changedEntry.id]: {
            ...oldItem,
            ...newItem
          }
        }
      };

      return {
        ...state,
        ...mergedEntry
      };
    }
    default:
      return state;
  }
}
#+END_SRC
- I think this is a little much for one function. The advice from redux is to break functions out, and I think you can easily see how to do that. It makes things easier to read but doestnt actually reduce lines of code, which I think is the real issue here.

* Refactoring

This talk has examples from my experiences refactoring a redux app.
 
* Keys conclusion

 - So by 'keys' I mean two things, the first, more obviously, is the meaning of keys items to access values in an object. Secondly I mean keys in DJ Khaled's sense, as ways to open doors to further success. These are some of the more abstract pieces of advice based on things that I have learned, and based on Dj Khalid's key taxonomy, can be roughly divided into minor and major keys. Minor keys are often called 'tips' and concrete examples of things you can do to improve experience, things like, 'enable redux developer tools' or 'always surround yourself with pillows' that are practical tips based that can be directly copied to similar scenarios.
      
 - The second of Khalid's keys, Major Keys, are higher up on the levels of abstraction. Link Cheng Lou on the spectrum of abstraction, very important talk [fn:5], (power === access to other tree levels) these have more universal principles but are are harder to describe in concrete terms, they are often highly metaphorical or strange sounding in terms of domain specific language. for example 'secure the bag' or 'keep two kitchens running'. They may sound nonsensical without the appropriate knowledge but these kinds of advice are similar to old sayings, like 'yagni' in programming and take extra effort to apply to a concrete case but have a larger amount of potential.



* Footnotes

[fn:5] [[https://www.youtube.com/watch?v=mVVNJKv9esE][Cheng Lou - On the Spectrum of Abstraction at react-europe 2016]]

[fn:4] DJ Khaled clips and sound

[fn:3] Test this out.

[fn:2] slite showing new object

[fn:1] slide showing mutation
