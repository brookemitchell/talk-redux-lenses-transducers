* Mihi / Greeting
  - Thank you to the conference organizers and other speakers
     
  - Especially those tackling topics, either technically or emotionally and those that address the wider definition of what our community means, sad I can't see them all. This is my first ever talk so thank-you for having me. I think the js community is wide and varied all levels and kinds of experience are important

  - I'm Brooke Mitchell. 

  - I've a developer who has been using JavaScript in earnest for maybe three years. 

   - These are my experiences using lenses and transducers to simplify data manipulation in a redux app I built. 

* Intro - Me and Redux / Clearing up nomenclature

 - My last year I have been pretty heavily focused on react and redux. Don't worry this isn't a talk about react. This talk is a little about my experiences using redux. Really this talk is really about how to deal with pojos (plain old JavaScript objects) (A.K.A dictionaries, hash-maps) something we all use. 

 -  From my experience dictionary manipulation can seems to be one of the less glamorous corners of functional programming; which is actually handy because it skips a lot of prior knowledge expected and you should be able to use any of these techniques in your day-to-day programming. One thing you will notice when using redux, the architecture tends to channel you towards functional approaches, I think is largely due to the inspiration takes from the ELM architecture.

 - Btw when I talk about objects/dictionaries/hash-maps in this talk, I mean pojos. eg {}. No fancy prototypal inheritance here. So since this talk is about my experiences using objects, this talk is about how we use objects, through keys. What are keys? Keys are probably one of the few things in the computing world that I like the name of. They are the items that you provide to a hash function that unlock associated values.  So and when we talk about keys, there is something slightly magical and metaphorical about them. For that reason we should also consider them at a higher conceptual level and consult the master of keys, the one and only, DJ Khaled. [fn:4]
    
 - For those unfamiliar with the work of DJ Khaled, you could briefly describe him as a music mogul and internet celebrity. Perhaps his most impressive skill is to act like a human hash function, and I mean that in a positive way. He can make a meaningful connection between any two people. Say you need Jay-Z and Snoop Dogg to catch a plane to your studio talk to DJ Khaled. So while Khaled is an important music producer, snapchat celebrity, motivational speaker but most importantly for this talk, he is someone who also has a philosophy about keys. (play Khaled keys clip). Khaled describes his steps to success as 'keys' that open access to other keys, so perhaps in another life he dealt with deeply nested JSON responses, lame joke I'm sorry. 
      
   - I use Ramda and es6 style functions in the examples in this talk. I use ramda for three things really, auto-currying fn(arg1)(arg2), function composition (R.compose(z, y, x)/R.pipe(x, y, z)) and applicatives(R.ap([fn1, fn2, fn3])). This talk isn't really about ramda or trying to convince you to use it, but it is a useful grab bag of mostly time honoured functional programming tricks that  it is handy to be aware of.

* Explaining how to build a redux app
*** Crash course in Redux
 - Anyway back to the app I was building. Sadly it was built for a closed source environment. But here is a smaller toy example that also shows some of the problems that as redux apps get larger. 

...Show app.

Before I show some of the refactorings I think are useful for dealing with objects, I'll try and offer as quick an overview of redux as possible. Hopefully my overview shows you that redux is very similar to mapping and reducing in vanilla js.

- So just to briefly describe what a redux app flow is like from 10,000 feet: 
  You have a store object that holds state.
1. You call store.dispatch(action) -> 
2. The Redux store calls any reducer functions (called 'reducers') that will make changes to state. ->
3. The Redux store replaces the old state tree with a new state tree.
   ...
4. You can subscribe to store updates to apply them to your view. 
   
That's pretty much it, talk over.

- So when building a redux app, apart from the boilerplate, you are essentially doing only two things, writing reducers to hanlde updates and mapping that state to your view. Thats it, reducing and mapping an object.

*** Reducer

Coincidentally a 'reducer' in redux is effectively a 'reduce' for state, I like to think of it like so...

#+BEGIN_SRC js 
const initialState = {loading: true, filter: all}

['ACTION 1', 'STOP_LOADING', 'ACTION 3']
  .reduce((state, action) => {
    if (action.type === 'STOP_LOADING') {
      return Object.assign({}, state, {loading: false})
    }
    else return state
    }
  },  initialState)
#+END_SRC

In reality that list of actions is provided by redux's dispatch function and unfolds over time, more like an observer, but I think its a good way to conceptualize it.

Take special note of the line that looks like this:
#+BEGIN_SRC js 
return Object.assign({}, oldObject, newObject)
#+END_SRC

- Major key alert: don't mutate your state in a reducer. It's an effort that will be ignored anyway in the diff comparison. [fn:3]  What is mutation? Here are some links properly discussing mutation on my slides which you can grab on github. [[https:github.com/brookemitchell][github link]]. Anyway the opposite of mutability is immutability, what is immutability, basically it means keys and values of an object are unchangeable. In practice that means we need to return a fresh new copy of the object every time. [fn:2] ]

*** Mapper
     
Here is a redux mapping of state to a html output, this is pretty low-level and in reality react users tend to use higher-order-components like react-redux connect [[http:github.com/react-redux/react-redux][connect link]], but just to show you that you could happily use redux store in any scenario.

This is a state mapper in hyperscript, a handy way to generate dom nodes directly.
#+BEGIN_SRC js 
import h from 'hyperscript'

const widgetsList = widgets => h('div', h('ul', widgets.map(w => h('li', w))))
let divWithState = h('div', h('text', 'loading...'))
store.subscribe(() => {
  const currentState = store.getState()
  divWithState = widgetsList(currentState.widgets)
})
#+END_SRC

I think writing functions instead of jsx looks pretty nice. JSX is cool too though.

State mappers are pretty much exactly the same for all libraries, I think of them like a .map where you plucks the desired items for an object. 

This is a state mapper using nanocomponent. An very cool new component createion library that runs on any framework and performs well (using the same optimizations as react fiber). It should be compatable with all the frameworks and x-to-js compilers (even elm) and frees us from writing the same components like inifite list a zillion times.

#+BEGIN_SRC js 
const component = require('nanocomponent')
const html = require('bel')

const mapStateToProps = state => ({widgets: state.widgets})
const props = mapStateToProps(store.getState())

var WidgetList = component({
  render: function (props) {
    return html`
      <ul>${props.widgets.map(e => html`<li>${e}</li>`)}</ul>
    `
  }
})
#+END_SRC

Anyway dispatch, reduce, map. That is my summary of redux, so enough of that.

* Refactoring a real app
**** Intro
- Hopefully you can now see that setting state is the same as applying a reducing function, and getting state is similar to a mapping over state and plucking entries you care about out.
**** Refactoring mapStateToProps
***** Starting point
- And here is a troubled mapper. In my toy example as is often the case things weren't looking real world enough, so I decided to implement some feature creep, user management and routing. Again you dont need to read this, just get a bad feeling that all this logic shouldn't really be in a view.

#+BEGIN_SRC js 
const mapStateToProps = state => {
  const user = state.users[state.routeParams.uid]
  const userDetails = state.usersDetails[user.uid]
  return {
    userDetails,
    noUser: typeof user === 'undefined',
    name: noUser ? '' : user.info.name,
    lastUpdatedUser: user ? user.lastUpdated : 0,
    isFetching: user.isFetching || usersDetails.isFetching,
    error: users.error || usersDetails.error,
    works: state.works.works,
    sending: state.works.sending,
    works: state.works.error,
    editing: R.propOr([], 0)(R.toPairs(state.works.editing))
  };
};
#+END_SRC
- For a quick glance this looks like way too much business logic to have in a view. Also all this nested parameter access is sure to cause runtime errors if a property isn't available at a certain point in time. Key alert: use ramda/lodash 'get' instead.
  
***** Step one, create selectors
- The first step taken is usually to get this property access out of the view and somewhere else. Usually I just make a selector file and work from there, it helps with testing, and we remove the any logic or intermediary functions from the view.

#+BEGIN_SRC js 
// selectors.js
const user = state => state.users[state.routeParams.uid]
const noUser = state =>  typeof user(state) === 'undefined'
const works$ =  state => state.works.works
const editing = state => state.works.editing
const editing$ =  R.compose(R.propOr([], 0),
                                   R.toPairs,
                                   editing)

//container.js
export const mapStateTo = (state) => {
  return {
    name: name$(state),
    userDetails : userDetails$(state),
    error: error$(state),
    editing: editing$(state)
  };
};
#+END_SRC

- We could go further but good enough I say, at least these are easily composable and testable now. We could take this even further and create an uber selector that combines all the selectors. 

***** Step Two: Composing with ramda
Major key: compose selectors.

#+BEGIN_SRC js 
// selectors.js
export const stateToProps$ = R.compose(
  R.zipObj(['name', 'userDetails', 'error', 'editing']),
  R.ap([
    name$,
    userDetails$,
    error$,
    editing$
    ]),
  R.of,
)

//container.js
const mapStateToProps = stateToProps$(store.getState())
  #+END_SRC
 - Wayyy sweeter. tbh this is probably the sweet spot. Go deeper if needs require.
***** Reselect  

_ The alternative route to composing selectors is to use a selector library like reselect. [[https://github.com/react/reselect] [reselect link]]  You get the same ability to compose selectors in a library. You also get the win of createSelector memoizing the results for you. This means that if anytime the result from all the selectors is the same, createSelector doesn't bother calculating the state again, this should save a few cpu cycles but in my experience doesn't offer major speed ups, not like a virtualdom-diff for example, but it's still nice not to create a new object every time.

#+BEGIN_SRC js
import { createSelector } from 'reselect'
const isFetching = createSelector(
  [ user, userDetails ],
  (user, userDetails) => user.isFetching || usersDetails.isFetching,
)

export const stateToProps$ = createSelector(
  [name$, userDetails$, error$, editing$],
  R.mergeAll,
)
#+END_SRC

***** Ramda Reselect  
      
My issue with reselect is it re-invents the wheel a bit when you could just take the time to learn composition and not sweat the difference when frameworks change.
      
#+BEGIN_SRC js
const shopItemsSelector = state => state.shop.items

const subtotalSelector = R.compose(
  R.reduce((acc, item) => acc + item.value, 0)
  shopItemsSelector,
)
#+END_SRC

Ok this is very close, and probably good enough for most scenarios. We could just as easily use composition to create similar functionality and keep a lot of flexibility. In fact here is the same functionality as what I need from reselect, selector composition, in a ramda one-ish liner using applicatives. Try not to read this and just get a feeling that we've just composed together our own reselect library from existing pieces.

#+BEGIN_SRC js
const createSelector = (...fns) => 
  R.compose(
    , R.apply(R.memoize(R.last(fns))))
    , R.ap(fns.slice(0, -1))
    R.of

export const stateToProps$ = createSelector(
  name$, userDetails$, error$, editing$, R.mergeAll,
)
#+END_SRC

- This does the same thing as createSelector, takes the state, runs it through a list of selectors (except the last one) then applies those values to the last function, which has been memoized.

- Now we get memoize and we dont have to learn another library. There are other capabilities reselect has which I've never used. Like props, you'll notice I pretty much never use props.

-  Thats another key I've found, focus on state for stateful components and just use props with pure components to keep things simple. Things don't always work out that way but I find that really helps keep things simple. 

- I have a more fully featured version of ramda-reselect that passes reselects test library in case you ever want to use it, or hopefully just look at the source, it's only a few lines more. npm.com/ernusame/ramda-reselect
  
- So I feel like we've slimmed down our stateToProps mapper pretty nicely. (show again)
#+BEGIN_SRC js
export const stateToProps$ = createSelector(
  name$, userDetails$, error$, editing$, R.mergeAll,
)
#+END_SRC

Now lets take a look at our reducer.

**** Refactoring reducer

 - Here is the real reducer for the roadworks editing app, this is the function for setting the new shape of the state called every time an 'action' is dispatched. 

#+BEGIN_SRC js 
export default function works(state = initialState, action) {
  switch (action.type) {
    case WORKS_FETCH_FAILED: {
      return {
        ...state,
        appState: "error",
        error: action.message
      };
    }
    case SET_TEXT: {
      const oldItem = state.works[action.changedEntry.id];
      const newItem = action.changedEntry[action.changedEntry.id];

      const mergedEntry = {
        works: {
          ...state.works,
          [action.changedEntry.id]: {
            ...oldItem,
            ...newItem
          }
        }
      };

      return {
        ...state,
        ...mergedEntry
      };
    }
    default:
      return state;
  }
}
#+END_SRC
- I think this is a little much for one function. The advice from redux is to break functions out, and I think you can easily see how to do that. It makes things easier to read but doestnt actually reduce lines of code, which I think is the real issue here.

#+BEGIN_SRC js 
function setText (state, action) {...}

export default function works(state = initialState, action) {
    ...
    case SET_TEXT: {
    setText(state, action)
    }
    ...
}
#+END_SRC

- Thats nice but we're just pushing code around now. I'm not always sure shepherding code around into files is a good idea, to me it always feels a little dishonest. How about trying something else, an abstraction that allows you to target a specific part of a deeply nested object, then returns the entire object. I'm talking about:

**** Lenses!
     - W
     - Here is a rewrite of the SET_TEXT actions reducing case.

#+BEGIN_SRC js 
    case SET_TEXT: {
      const id = action.changedEntry.id;
      const value = action.changedEntry[id];
      const key = R.keys(action.changedEntry[id])[0]; // => 'type'
      const worksItemLens = R.lensPath(['works', 'works', id])
      return R.set(worksItemLens, value, state); //=> {works: {works: {160192: {id:"160192", code:"544989" type:"New Value"... }}}
    }
#+END_SRC

To me this is way cleaner. And get ready for the second win, your lenses act as both getters and setters, so you get selectors for free when you write them. Major key. I stop thinking in terms of reducers now and just think of writing a selector as a lens when I need something, compose lenses together for my mapStateToProps,  and later I can use it to set the change I've dispatched in the reducer.

One of the fun things about lenses is they look like they compose left to right. It's a little confusing  

#+BEGIN_SRC js
const userLens = R.lensProp('users')
const uidLens = R.lensPath(['routeParams', 'uid'])
export const userInfoLens = R.compose(userLens, uidLens)
export const userNameLens = R.lensPath(['info', 'name'])
export const nameLens = R.compose(userInfo, userNameLens)

export const errorLens = R.lensPath(['works','error'])
export const editingLens = R.lensPath(['works', 'editing'])

const mapStateToProps =  R.compose(
  R.mergeAll,
  R.ap(R.map (R.view, 
    [editingLens, errorLens, nameLens] ))
  R.of, 
);

    case SET_EDITING: {
      return R.over(worksItemLens,  , state); //=> {works: {works: {160192: {id:"160192", code:"544989" type:"New Value"... }}}
    }
#+END_SRC

* Keys conclusion

 - So by 'keys' I mean two things, the first, more obviously, is the meaning of keys items to access values in an object. Secondly I mean keys in DJ Khaled's sense, as ways to open doors to further success. These are some of the more abstract pieces of advice based on things that I have learned, and based on Dj Khalid's key taxonomy, can be roughly divided into minor and major keys. Minor keys are often called 'tips' and concrete examples of things you can do to improve experience, things like, 'enable redux developer tools' or 'always surround yourself with pillows' that are practical tips based that can be directly copied to similar scenarios.
   
- I've tried not to say that a technology or a technique is a key, I dont think lenses are better than mapping for example. Lenses have a lot of pitfalls and can be way overkill. But the approach that they represent, of simplifying by looking for similarity between mapping and reducing to refactor code is the key that I like. 
      
 - Major Keys, tend to be concepts that are higher up on the levels of abstraction. Link Cheng Lou on the spectrum of abstraction, very important talk [fn:5], (power === access to other tree levels) these have more universal principles but are are harder to describe in concrete terms, they are often highly metaphorical or strange sounding in terms of domain specific language. for example 'secure the bag' or 'keep two kitchens running'. They may sound nonsensical without the appropriate knowledge but these kinds of advice are similar to old sayings, like 'yagni' in programming and take extra effort to apply to a concrete case but have a larger amount of potential.
   
 - Alan Kay - Build things with knowledge and technique. Using a higher level form can remove loc in orders of magnitude, depending on choice of abstraction.



* Footnotes

[fn:5] [[https://www.youtube.com/watch?v=mVVNJKv9esE][Cheng Lou - On the Spectrum of Abstraction at react-europe 2016]]

[fn:4] DJ Khaled clips and sound

[fn:3] Test this out.

[fn:2] slite showing new object

[fn:1] slide showing mutation
